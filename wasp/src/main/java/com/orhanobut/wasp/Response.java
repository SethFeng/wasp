package com.orhanobut.wasp;

import com.android.volley.toolbox.HttpHeaderParser;
import com.orhanobut.wasp.utils.LogLevel;

import java.util.Collections;
import java.util.Map;

public final class Response {

  private final int statusCode;
  private final int length;
  private final long networkTime;

  private final Object responseObject;
  private final Map<String, String> headers;
  private final byte[] body;
  private final String url;
  private final LogLevel logLevel;

  private Response(Builder builder) {
    this.url = builder.getUrl();
    this.statusCode = builder.getStatusCode();
    this.headers = builder.getHeaders();
    this.body = builder.getBody();
    this.length = builder.getLength();
    this.networkTime = builder.getNetworkTime();
    this.responseObject = builder.getResponseObject();
    this.logLevel = Wasp.getLogLevel();
  }

  /**
   * Request URL.
   */
  public String getUrl() {
    return url;
  }

  /**
   * HTTP status code.
   */
  public int getStatusCode() {
    return statusCode;
  }

  /**
   * An unmodifiable map of headers.
   */
  @SuppressWarnings("unused")
  public Map<String, String> getHeaders() {
    return headers;
  }

  /**
   * Response body. May be {@code null}.
   */
  @SuppressWarnings("unused")
  public byte[] getBody() {
    return body;
  }

  /**
   * Response body length.
   */
  @SuppressWarnings("unused")
  public int getLength() {
    return length;
  }

  /**
   * Returns the response object which is generated by checking CallBack<T>
   */
  Object getResponseObject() {
    return responseObject;
  }

  /**
   * Network time elapsed for request to be completed.
   */
  @SuppressWarnings("unused")
  public long getNetworkTime() {
    return networkTime;
  }

  private String getFormattedBody() {
    try {
      return (new String(body, HttpHeaderParser.parseCharset(headers, "UTF-8")))
              .replace("\n", "").replace("\r", "").replace("\t", "");
    } catch (Exception e) {
      e.printStackTrace();
    }
    return null;
  }

  void log() {
    switch (logLevel) {
      case FULL:
        // Fall Through
      case FULL_REST_ONLY:
        Logger.d("<--- RESPONSE " + statusCode + " " + url);
        if (!headers.isEmpty()) {
          for (Map.Entry<String, String> entry : headers.entrySet()) {
            Logger.d("Header - [" + entry.getKey() + ": " + entry.getValue() + "]");
          }
        }
        Logger.d(body == null ? "Body - no body" : "Body - " + getFormattedBody());
        Logger.d("<--- END " + "(Size: " + length + " bytes - Network time: "
            + networkTime + " ms)");
        break;
      default:
        // Method is called but log level is not meant to log anything
    }
  }

  static class Builder {

    private String url;
    private Map<String, String> headers;
    private byte[] body;
    private Object responseObject;

    private int statusCode;
    private int length;
    private long networkTime;

    Response build() {
      return new Response(this);
    }

    String getUrl() {
      return url;
    }

    Builder setUrl(String url) {
      this.url = url;
      return this;
    }

    int getStatusCode() {
      return statusCode;
    }

    Builder setStatusCode(int statusCode) {
      this.statusCode = statusCode;
      return this;
    }

    Map<String, String> getHeaders() {
      return headers != null ? headers : Collections.<String, String>emptyMap();
    }

    Builder setHeaders(Map<String, String> headers) {
      this.headers = headers;
      return this;
    }

    byte[] getBody() {
      return body;
    }

    Builder setBody(byte[] body) {
      this.body = body;
      return this;
    }

    int getLength() {
      return length;
    }

    Builder setLength(int length) {
      this.length = length;
      return this;
    }

    long getNetworkTime() {
      return networkTime;
    }

    Builder setNetworkTime(long networkTime) {
      this.networkTime = networkTime;
      return this;
    }

    Object getResponseObject() {
      return responseObject;
    }

    Builder setResponseObject(Object object) {
      this.responseObject = object;
      return this;
    }
  }
}
